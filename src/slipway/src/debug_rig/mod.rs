use crate::json_editor::{JsonEditor, JsonEditorImpl};
use anyhow::Context;
use handle_command::{HandleCommandResult, handle_command};
use serde_json::json;
use slipway_host::render_state::write_state;
use std::io::{self, Write};
use std::path::PathBuf;
use std::str::FromStr;
use std::sync::Arc;
use termion::{color, style};

use slipway_engine::{
    BasicComponentCache, BasicComponentsLoader, CallChain, ComponentHandle, ComponentRigging,
    Environment, Permissions, Rig, RigSession, RigSessionOptions, Rigging, SlipwayReference,
    parse_rig,
};

use crate::component_runners::get_component_runners;

mod errors;
mod handle_clear_input_command;
mod handle_clear_output_command;
mod handle_command;
mod handle_input_command;
mod handle_output_command;
mod handle_render_command;
mod handle_run_command;

pub(crate) use errors::SlipwayDebugError;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(
    name = "Slipway Interactive Debugger",
    bin_name = "",
    long_about = r#"

The component graph displays the component handles and their connections. The
square indicates if a component has an input or output set. Components with an
input can be run.

Shortcuts can be used for component handles, and are indicated by the
underlined portion of the name.

The column to the right of the graph displays the input and output hashes of
each component. If a hash is underlined it means the input or output has been
overridden. If the output is green and is preceded by an arrow it means the
output was generated by the input. If the output is red or is preceded by an
exclamation mark it means the output was not generated from the input (the
output may have been overridden, or the input may have changed).

The final column shows the input and output sizes for each component."#
)]
#[command(color = clap::ColorChoice::Auto)]
#[command(styles = super::get_styles())]
struct DebugCli {
    #[command(subcommand)]
    command: DebuggerCommand,
}

#[derive(Subcommand)]
enum DebuggerCommand {
    /// Prints the component graph.
    Print {},

    /// Run a component.
    Run {
        /// The component to run.
        #[arg(required = true)]
        handle: String,
    },

    /// Override or view the input of a component.
    Input {
        /// The component to update.
        #[arg(required = true)]
        handle: String,

        /// Clear the input override.
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Override or view the output of a component.
    Output {
        /// The component to update.
        #[arg(required = true)]
        handle: String,

        /// Clear the output override.
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Render the output of a component.
    Render {
        /// The component to render.
        #[arg(required = true)]
        handle: String,

        /// The optional file path to save the rendered output.
        #[arg(short, long)]
        save: Option<std::path::PathBuf>,
    },

    /// Exit the debugger.
    Exit,
}

#[cfg(test)]
impl DebugCli {
    fn for_test(command: &str) -> Self {
        let mut args = command.split_whitespace().collect::<Vec<&str>>();
        args.insert(0, "slipway");
        Self::try_parse_from(args).expect("Should parse")
    }
}

pub(crate) async fn debug_rig_from_component_file<W: Write>(
    w: &mut W,
    component_reference: SlipwayReference,
    input: Option<String>,
    input_path: Option<std::path::PathBuf>,
    component_permissions: Permissions<'_>,
    registry_urls: Vec<String>,
    fonts_path: Option<PathBuf>,
) -> anyhow::Result<()> {
    writeln!(w, "Debugging {}", component_reference)?;
    let json_editor = JsonEditorImpl::new();
    let initial_input = get_component_input(w, input, input_path, &json_editor)?;
    let rig = get_component_rig(component_reference, &component_permissions, initial_input);

    // We created the rig, so we can trust it to only pass on the user specified
    // component_permissions to the component.
    // At minimum we would need component_permissions plus permission to load the
    // component, but there is no advantage to being more restrictive here.
    let rig_permissions = Permissions::allow_all();

    debug_rig(
        w,
        rig,
        json_editor,
        rig_permissions,
        registry_urls,
        fonts_path,
    )
    .await
}

pub(super) fn get_component_rig(
    component_reference: SlipwayReference,
    component_permissions: &Permissions<'_>,
    initial_input: serde_json::Value,
) -> Rig {
    Rig {
        description: None,
        constants: None,
        rigging: Rigging {
            components: [(
                ComponentHandle::from_str("wrapped").unwrap(),
                ComponentRigging {
                    component: component_reference,
                    input: Some(initial_input),
                    allow: Some(component_permissions.allow.to_vec()),
                    deny: Some(component_permissions.deny.to_vec()),
                    permissions_chain: None,
                    callouts: None,
                },
            )]
            .into_iter()
            .collect(),
        },
    }
}

pub(super) fn get_component_input<W: Write>(
    w: &mut W,
    input: Option<String>,
    input_path: Option<PathBuf>,
    json_editor: &JsonEditorImpl,
) -> Result<serde_json::Value, anyhow::Error> {
    let initial_input = match input {
        None => match input_path {
            None => {
                writeln!(w, "Enter initial component input...")?;
                let input = json_editor.edit(&json!({}))?;
                writeln!(w, "...done")?;
                writeln!(w)?;
                input
            }
            Some(input_path) => {
                serde_json::from_str(&std::fs::read_to_string(input_path.clone()).with_context(
                    || format!("Failed to read input from {}", input_path.display()),
                )?)?
            }
        },
        Some(input) => serde_json::from_str(&input)
            .with_context(|| format!("Failed to parse JSON input from string: {}", input))?,
    };
    Ok(initial_input)
}

pub(crate) async fn debug_rig_from_rig_file<W: Write>(
    w: &mut W,
    input: std::path::PathBuf,
    engine_permissions: Permissions<'_>,
    registry_urls: Vec<String>,
    fonts_path: Option<PathBuf>,
) -> anyhow::Result<()> {
    writeln!(w, "Debugging {}", input.display())?;

    let file_contents = std::fs::read_to_string(input.clone())
        .with_context(|| format!("Failed to read component from {}", input.display()))?;
    let rig = parse_rig(&file_contents)?;

    let json_editor = JsonEditorImpl::new();

    debug_rig(
        w,
        rig,
        json_editor,
        engine_permissions,
        registry_urls,
        fonts_path,
    )
    .await
}

fn redirect_to_json_if_wasm(input: &std::path::Path) -> std::path::PathBuf {
    if input.extension().map(|e| e == "wasm").unwrap_or(false) {
        let mut new_path = input.to_owned();
        new_path.set_extension("json");
        new_path
    } else {
        input.to_owned()
    }
}

async fn debug_rig<W: Write>(
    w: &mut W,
    rig: Rig,
    json_editor: impl JsonEditor,
    engine_permissions: Permissions<'_>,
    registry_urls: Vec<String>,
    fonts_path: Option<PathBuf>,
) -> anyhow::Result<()> {
    let components_loader = BasicComponentsLoader::builder()
        .registry_lookup_urls(registry_urls)
        .build();

    let timezone = iana_time_zone::get_timezone()?;
    let locale = sys_locale::get_locale().unwrap_or(crate::DEFAULT_LOCALE.to_string());
    let component_cache = BasicComponentCache::primed(&rig, &components_loader).await?;
    let session_options = RigSessionOptions::new_for_run(
        false,
        fonts_path.as_deref(),
        Environment { timezone, locale },
    )
    .await;
    let session = RigSession::new_with_options(rig, &component_cache, session_options);
    let mut state = session.initialize()?;

    let component_runners = get_component_runners();

    write_state::<_, anyhow::Error>(w, &state)?;

    let help_color = color::Fg(color::Yellow);
    writeln!(
        w,
        "{}Type {}help{}{} for commands.{}",
        help_color,
        style::Underline,
        style::Reset,
        help_color,
        color::Fg(color::Reset)
    )?;

    let permissions_chain = Arc::new(CallChain::new(engine_permissions));

    loop {
        write!(
            w,
            "{}⛵️ >> {}",
            color::Fg(color::Green),
            color::Fg(color::Reset)
        )?;
        w.flush().unwrap();

        let mut input = String::new();
        if io::stdin().read_line(&mut input).is_ok() {
            let mut args = input.split_whitespace().collect::<Vec<&str>>();
            if args.is_empty() {
                continue;
            }

            args.insert(0, "slipway");

            match DebugCli::try_parse_from(args) {
                Ok(result) => {
                    match handle_command(
                        w,
                        result,
                        &state,
                        &json_editor,
                        &component_runners,
                        Arc::clone(&permissions_chain),
                    )
                    .await
                    {
                        Ok(HandleCommandResult::Continue(Some(s))) => {
                            state = s;
                            write_state::<_, anyhow::Error>(w, &state)?;
                        }
                        Ok(HandleCommandResult::Continue(None)) => {}
                        Ok(HandleCommandResult::Exit) => break,
                        Err(e) => {
                            writeln!(
                                w,
                                "{}{}{}",
                                color::Fg(color::Red),
                                e,
                                color::Fg(color::Reset)
                            )?;
                            write_state::<_, anyhow::Error>(w, &state)?;
                        }
                    }
                }
                Err(e) => e.print().expect("Parsing errors should be printed"),
            }
        } else {
            writeln!(w, "Error reading input")?;
        }
    }

    writeln!(w, "Exiting...")?;

    Ok(())
}
