use anyhow::Context;
use handle_command::{handle_command, HandleCommandResult};
use json_editor::{JsonEditor, JsonEditorImpl};
use serde_json::json;
use std::io::{self, Write};
use std::str::FromStr;
use std::sync::Arc;
use termion::{color, style};

use slipway_engine::{
    parse_rig, BasicComponentCache, BasicComponentsLoader, ComponentHandle, ComponentPermission,
    ComponentRigging, Name, CallChain, Publisher, Rig, RigSession, Rigging, SlipwayReference,
};

use crate::component_runners::get_component_runners;
use crate::render_state::write_state;

mod errors;
mod handle_clear_input_command;
mod handle_clear_output_command;
mod handle_command;
mod handle_input_command;
mod handle_output_command;
mod handle_render_command;
mod handle_run_command;
mod json_editor;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(
    name = "Slipway Interactive Debugger",
    bin_name = "",
    long_about = r#"

The component graph displays the component handles and their connections. The
square indicates if a component has an input or output set. Components with an
input can be run.

Shortcuts can be used for component handles, and are indicated by the
underlined portion of the name.

The column to the right of the graph displays the input and output hashes of
each component. If a hash is underlined it means the input or output has been
overridden. If the output is green and is preceded by an arrow it means the
output was generated by the input. If the output is red or is preceded by an
exclamation mark it means the output was not generated from the input (the
output may have been overridden, or the input may have changed).

The final column shows the input and output sizes for each component."#
)]
struct DebugCli {
    #[command(subcommand)]
    command: DebuggerCommand,
}

#[derive(Subcommand)]
enum DebuggerCommand {
    /// Prints the component graph
    Print {},

    /// Run a component
    Run {
        /// The component to run
        #[arg(required = true)]
        handle: String,
    },

    /// Override or view the input of a component
    Input {
        /// The component to update
        #[arg(required = true)]
        handle: String,

        /// Clear the input override
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Override or view the output of a component
    Output {
        /// The component to update
        #[arg(required = true)]
        handle: String,

        /// Clear the output override
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Render the output of a component
    Render {
        /// The component to render
        #[arg(required = true)]
        handle: String,

        /// The optional file path to save the rendered output
        #[arg(short, long)]
        save: Option<std::path::PathBuf>,
    },

    /// Exit the debugger
    Exit,
}

#[cfg(test)]
impl DebugCli {
    fn for_test(command: &str) -> Self {
        let mut args = command.split_whitespace().collect::<Vec<&str>>();
        args.insert(0, "slipway");
        Self::try_parse_from(args).expect("Should parse")
    }
}

pub(crate) fn debug_rig_from_component_file<W: Write>(
    w: &mut W,
    component_path: std::path::PathBuf,
    input_path: Option<std::path::PathBuf>,
    engine_permissions: Vec<ComponentPermission>,
) -> anyhow::Result<()> {
    writeln!(w, "Debugging {}", component_path.display())?;
    writeln!(w)?;

    if !component_path.exists() {
        writeln!(w, "Component file does not exist")?;
        return Ok(());
    }

    let component_path = redirect_to_json_if_wasm(&component_path);

    let component_reference = match component_path.is_absolute() {
        true => {
            SlipwayReference::from_str(&format!("file://{}", component_path.to_string_lossy()))?
        }
        false => SlipwayReference::from_str(&format!("file:{}", component_path.to_string_lossy()))?,
    };

    let json_editor = JsonEditorImpl::new();

    writeln!(w, "Enter initial component input...")?;
    let initial_input = match input_path {
        None => json_editor.edit(&json!({}))?,
        Some(input_path) => serde_json::from_str(
            &std::fs::read_to_string(input_path.clone())
                .with_context(|| format!("Failed to read input from {}", input_path.display()))?,
        )?,
    };

    writeln!(w, "...done")?;
    writeln!(w)?;

    let rig = Rig {
        publisher: Publisher::from_str("test").expect("generated rig publisher should be valid"),
        name: Name::from_str("test").expect("generated rig name should be valid"),
        version: semver::Version::parse("0.0.1").expect("generated rig version should be valid"),
        description: None,
        constants: None,
        rigging: Rigging {
            components: [(
                ComponentHandle::from_str("test").unwrap(),
                ComponentRigging {
                    component: component_reference,
                    input: Some(initial_input),
                    permissions: None,
                    callouts: None,
                },
            )]
            .into_iter()
            .collect(),
        },
    };

    debug_rig(w, rig, json_editor, engine_permissions)
}

pub(crate) fn debug_rig_from_rig_file<W: Write>(
    w: &mut W,
    input: std::path::PathBuf,
    engine_permissions: Vec<ComponentPermission>,
) -> anyhow::Result<()> {
    writeln!(w, "Debugging {}", input.display())?;
    writeln!(w)?;

    let file_contents = std::fs::read_to_string(input.clone())
        .with_context(|| format!("Failed to read component from {}", input.display()))?;
    let rig = parse_rig(&file_contents)?;

    let json_editor = JsonEditorImpl::new();

    debug_rig(w, rig, json_editor, engine_permissions)
}

fn redirect_to_json_if_wasm(input: &std::path::Path) -> std::path::PathBuf {
    if input.extension().map(|e| e == "wasm").unwrap_or(false) {
        let mut new_path = input.to_owned();
        new_path.set_extension("json");
        new_path
    } else {
        input.to_owned()
    }
}

fn debug_rig<W: Write>(
    w: &mut W,
    rig: Rig,
    json_editor: impl JsonEditor,
    engine_permissions: Vec<ComponentPermission>,
) -> anyhow::Result<()> {
    let component_cache = BasicComponentCache::primed(&rig, &BasicComponentsLoader::default())?;
    let session = RigSession::new(rig, &component_cache);
    let mut state = session.initialize()?;

    let component_runners = get_component_runners();

    write_state(w, &state)?;

    let help_color = color::Fg(color::Yellow);
    writeln!(
        w,
        "{}Type {}help{}{} for commands.{}",
        help_color,
        style::Underline,
        style::Reset,
        help_color,
        color::Fg(color::Reset)
    )?;

    let permissions_chain = Arc::new(CallChain::new(&engine_permissions));

    loop {
        write!(
            w,
            "{}⛵️ >> {}",
            color::Fg(color::Green),
            color::Fg(color::Reset)
        )?;
        w.flush().unwrap();

        let mut input = String::new();
        if io::stdin().read_line(&mut input).is_ok() {
            let mut args = input.split_whitespace().collect::<Vec<&str>>();
            if args.is_empty() {
                continue;
            }

            args.insert(0, "slipway");

            match DebugCli::try_parse_from(args) {
                Ok(result) => {
                    match handle_command(
                        w,
                        result,
                        &state,
                        &json_editor,
                        &component_runners,
                        Arc::clone(&permissions_chain),
                    ) {
                        Ok(HandleCommandResult::Continue(Some(s))) => {
                            state = s;
                            writeln!(w)?;
                            write_state(w, &state)?;
                        }
                        Ok(HandleCommandResult::Continue(None)) => {}
                        Ok(HandleCommandResult::Exit) => break,
                        Err(e) => {
                            writeln!(
                                w,
                                "{}{}{}",
                                color::Fg(color::Red),
                                e,
                                color::Fg(color::Reset)
                            )?;
                            writeln!(w)?;
                            write_state(w, &state)?;
                        }
                    }
                }
                Err(e) => e.print().expect("Parsing errors should be printed"),
            }
        } else {
            writeln!(w, "Error reading input")?;
        }
    }

    writeln!(w, "Exiting...")?;

    Ok(())
}
