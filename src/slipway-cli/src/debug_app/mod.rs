use std::io::{self, ErrorKind, Write};
use termion::{color, style};

use slipway_lib::{parse_app, AppExecutionState, AppSession, ComponentHandle, Immutable};

use crate::to_view_model::{to_shortcuts, to_view_model};
use crate::write_app_state;

use self::errors::SlipwayDebugError;

mod errors;
mod handle_clear_input_command;
mod handle_clear_output_command;
mod handle_input_command;
mod handle_output_command;
mod handle_run_command;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(
    name = "Slipway Interactive Debugger",
    bin_name = "",
    long_about = r#"

The component graph displays the component handles and their connections. The
square indicates if a component has an input or output set. Components with an
input can be run.

Shortcuts can be used for component handles, and are indicated by the
underlined portion of the name.

The column to the right of the graph displays the input and output hashes of
each component. If a hash is underlined it means the input or output has been
overridden. If the output is green and is preceded by an arrow it means the
output was generated by the input. If the output is red or is preceded by an
exclamation mark it means the output was not generated from the input (the
output may have been overridden, or the input may have changed).

The final column shows the input and output sizes for each component."#
)]
struct DebugCli {
    #[command(subcommand)]
    command: DebuggerCommand,
}

#[derive(Subcommand)]
enum DebuggerCommand {
    /// Prints the component graph
    Print {},

    /// Run a component
    Run {
        /// The component to run
        #[arg(required = true)]
        handle: String,
    },

    /// Override the input of a component
    Input {
        /// The component to update
        #[arg(required = true)]
        handle: String,

        /// Clear the input override
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Override the output of a component
    Output {
        /// The component to update
        #[arg(required = true)]
        handle: String,

        /// Clear the output override
        #[arg(short, long, default_value = "false")]
        clear: bool,
    },

    /// Exit the debugger
    Exit,
}

pub(crate) fn debug_app(input: std::path::PathBuf) -> anyhow::Result<()> {
    set_ctrl_c_handler();

    println!("Debugging {}", input.display());
    println!();
    let file_contents = std::fs::read_to_string(input)?;
    let app = parse_app(&file_contents)?;
    let session = AppSession::new(app, Default::default());
    let mut state = session.initialize()?;

    print_state(&state)?;

    let help_color = color::Fg(color::Yellow);
    println!(
        "{}Type {}help{}{} for commands.{}",
        help_color,
        style::Underline,
        style::Reset,
        help_color,
        color::Fg(color::Reset)
    );

    loop {
        print!("{}>> {}", color::Fg(color::Green), color::Fg(color::Reset));
        io::stdout().flush().unwrap();

        let mut input = String::new();
        if io::stdin().read_line(&mut input).is_ok() {
            let mut args = input.split_whitespace().collect::<Vec<&str>>();
            if args.is_empty() {
                continue;
            }

            args.insert(0, "slipway");

            match DebugCli::try_parse_from(args) {
                Ok(result) => match handle_command(result, &state) {
                    Ok(HandleCommandResult::Continue(Some(s))) => {
                        state = s;
                        println!();
                        print_state(&state)?;
                    }
                    Ok(HandleCommandResult::Continue(None)) => {}
                    Ok(HandleCommandResult::Exit) => break,
                    Err(e) => {
                        println!("{}{}{}", color::Fg(color::Red), e, color::Fg(color::Reset));
                        println!();
                        print_state(&state)?;
                    }
                },
                Err(e) => e.print().expect("Parsing errors should be printed"),
            }
        } else {
            println!("Error reading input");
        }
    }

    println!("Exiting application...");

    Ok(())
}

fn set_ctrl_c_handler() {
    ctrlc::set_handler(move || {
        std::process::exit(1);
    })
    .expect("Error setting Ctrl-C handler");
}

enum HandleCommandResult<'app> {
    Continue(Option<Immutable<AppExecutionState<'app>>>),
    Exit,
}

fn handle_command<'app>(
    matches: DebugCli,
    state: &AppExecutionState<'app>,
) -> anyhow::Result<HandleCommandResult<'app>> {
    let result = match matches.command {
        DebuggerCommand::Print {} => {
            print_state(state)?;
            HandleCommandResult::Continue(None)
        }
        DebuggerCommand::Run { handle } => {
            let handle = get_handle(&handle, state)?;
            let new_state = handle_run_command::handle_run_command(handle, state)?;
            HandleCommandResult::Continue(Some(new_state))
        }
        DebuggerCommand::Input { handle, clear } => {
            let handle = get_handle(&handle, state)?;

            match clear {
                true => {
                    let new_state =
                        handle_clear_input_command::handle_clear_input_command(handle, state)?;
                    HandleCommandResult::Continue(Some(new_state))
                }
                false => {
                    let new_state = handle_input_command::handle_input_command(handle, state)?;
                    HandleCommandResult::Continue(Some(new_state))
                }
            }
        }
        DebuggerCommand::Output { handle, clear } => {
            let handle = get_handle(&handle, state)?;

            match clear {
                true => {
                    let new_state =
                        handle_clear_output_command::handle_clear_output_command(handle, state)?;
                    HandleCommandResult::Continue(Some(new_state))
                }
                false => {
                    let new_state = handle_output_command::handle_output_command(handle, state)?;
                    HandleCommandResult::Continue(Some(new_state))
                }
            }
        }
        DebuggerCommand::Exit => HandleCommandResult::Exit,
    };

    Ok(result)
}

fn print_state(state: &AppExecutionState<'_>) -> Result<(), anyhow::Error> {
    let view_model = to_view_model(state);
    write_app_state::write_app_state(&mut io::stdout(), &view_model)?;
    println!();
    Ok(())
}

fn edit_json(template: &serde_json::Value) -> Result<serde_json::Value, SlipwayDebugError> {
    let template_string =
        serde_json::to_string_pretty(&template).expect("Component input should be serializable");
    let maybe_edited = edit::edit(template_string);
    match maybe_edited {
        Ok(edited) => {
            let result = serde_json::from_str(&edited)?;
            Ok(result)
        }
        Err(e) => match e.kind() {
            ErrorKind::InvalidData => Err(SlipwayDebugError::UserError(
                "Could not decode input as UTF-8".into(),
            )),
            ErrorKind::NotFound => {
                Err(SlipwayDebugError::UserError("Text editor not found".into()))
            }
            other_error => Err(SlipwayDebugError::UserError(format!(
                "Failed to open the file: {:?}",
                other_error
            ))),
        },
    }
}

fn get_handle<'app>(
    handle_str: &str,
    state: &AppExecutionState<'app>,
) -> Result<&'app ComponentHandle, SlipwayDebugError> {
    let shortcuts = to_shortcuts(state);

    if let Some(&handle) = shortcuts.get(handle_str) {
        return Ok(handle);
    }

    Err(SlipwayDebugError::UserError(format!(
        "No component found for handle or shortcut {}",
        handle_str
    )))
}
